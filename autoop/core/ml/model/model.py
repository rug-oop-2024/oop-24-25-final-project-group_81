from abc import ABC, abstractmethod
import numpy as np
from copy import deepcopy
import re

from autoop.core.ml.artifact import Artifact


class Model(ABC):
    """
    Represents a generic Machine Learning model.

    This class serves as a base class.
    """

    def __init__(self, type: str) -> None:
        """
        A way of instantiating a Model.
        """
        self._type = type
        self._parameters = {}

    @property
    def name(self) -> str:
        """
        Getter for the name of the model.

        :return: the formated name of the model
        :rtype: str
        """
        name = self.__class__.__name__
        name = re.sub(r"(?<!^)(?=[A-Z])", "_", name)
        return name

    @property
    def parameters(self) -> dict:
        """
        Return the model parameters.

        :return: A dictionary containing the model's parameters.
        """
        return deepcopy(self._parameters)

    @property
    def type(self) -> str:
        """
        Returns the type of the model.

        :type return: str
        """
        return self._type

    def to_artifact(self, name: str, version: str) -> Artifact:
        model = name
        path = "assets\\objects" + name
        params = self._parameters
        artifact = Artifact(
            name=model,
            type=self._type,
            version=version,
            asset_path=path,
            parameters=params,
            data=None,
        )
        return artifact

    @abstractmethod
    def fit(self, observations: np.ndarray, ground_truth: np.ndarray) -> None:
        """
         Fit the model to the observations and ground truth data.

        This method takes in observations (input data) and ground truth
        (actual values) and adjusts the model's parameters accordingly.

        :param observations: Input data or features the model will
        learn from.
        :type observations: np.ndarray
        :param ground_truth: Actual values of the target variable
            used to adjust the model's parameters during training.
        :type ground_truth: np.ndarray
        """
        pass

    @abstractmethod
    def predict(self, observations: np.ndarray) -> np.ndarray:
        """
        Make predictions using the model for the given observations.

        This method takes an array of observations as input and returns an
        array of predictions generated by the model.

        :param observations: Data or observations for which predictions
                             are to be made.
                             Should be a NumPy array with the
                             appropriate shape.
        :type observations: np.ndarray
        :return: Predictions as a NumPy array.
        :rtype: np.ndarray
        """
        pass

    def _validate_input(
        self, observations: np.ndarray, ground_truth: np.ndarray
    ) -> None:
        """
        Checks that the inut data is of the correct shape and dimensionality.

        :param observations: Input data or features
            the model will learn from or predict on.
        :type observations: np.ndarray
        :param ground_truth: Actual values of the target variable
            used during training.
        :type ground_truth: np.ndarray
        :raises ValueError: If the number of observations
            and ground_truth do not match.
        :raises ValueError: If observations is not a 2d array.
        :raises ValueError: If observations has no samples or no features.
        """
        if observations.shape[0] != ground_truth.shape[0]:
            raise ValueError(
                f"Mismatch in number of samples:"
                f"Observations have {observations.shape[0]} samples, "
                f"but ground truth has {ground_truth.shape[0]} samples."
            )

        if observations.ndim != 2:
            raise ValueError(
                "Observations should be a 2-D array, but got"
                f"{observations.ndim}D array instead."
            )

        num_samples, num_features = observations.shape
        if num_samples < 1 or num_features < 1:
            raise ValueError(
                "The input data must have at least"
                + " one sample and one feature."
            )

        if num_features > num_samples:
            print(
                "Warning: Detected more features than samples!"
                "Are you sure that the samples are in observations[0]"
                "and features in observations[1]?"
            )

        self._parameters["num_features"] = num_features

    def _validate_num_features(self, observations: np.ndarray) -> None:
        """
        Validate that the number of features in the input observations
        matches the number of features used during model fitting.

        :param observations: The input data for which
        predictions will be made.
        :raises ValueError: If the number of features
            during fit and predict differ.
        """
        num_features = self._parameters["num_features"]
        if num_features is not None and observations.shape[1] != num_features:
            raise ValueError(
                f"Number of dimensions from fitting the data"
                f"({num_features}) don't match input"
                f"observations in predicting the data"
                f"({observations.shape[1]})."
            )
