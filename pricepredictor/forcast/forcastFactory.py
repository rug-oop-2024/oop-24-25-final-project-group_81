import numpy as np
import tensorflow as tf
import pandas as pd
from sklearn.metrics import mean_squared_error
from copy import deepcopy

from pricepredictor.network.networkFactory import NetworkFactory
from pricepredictor.data_parser.dataFactory import StockDataFactory
from pricepredictor.\
    visualisation.visualize import PlotStocks, PlotForcastComparison


# Defining typehints:
RAW_DATA = list[tuple[str, float, float, float, float]]


class ForcastFactory:
    """
    Serves as a control point for making forcasts on data, using a NN.
    """

    def __init__(
        self,
        stock_name: str,
        model_param_dict: dict,
        datafactory_param_dict: dict
    ) -> None:
        """
        A way of initializing a ForcastFactory. There is
        a special class called ForecastFactoryInitializer that
        generates the model_param_dict and
        datafactory_param_dict for the instance of this object.

        :param stock_name: the name of the financial asset
        :type stock_name: str
        :param model_param_dict: the model dict as generated by
        ForecastFactoryInitializer
        :type model_param_dict: dict
        :param datafactory_param_dict: the datafactory dict as
        generated by ForecastFactoryInitializer
        :type datafactory_param_dict: dict
        """
        self._stock_name = stock_name

        # Unpack model parameters
        for key, value in model_param_dict.items():
            setattr(self, f"_{key}", value)

        # Unpack datafactory parameters
        for key, value in datafactory_param_dict.items():
            setattr(self, f"_{key}", value)

        # Define the model's activation functions
        activations = ["relu" for _ in range(len(self._architecture))]
        activations.append("linear")

        self._input_shape = self._points_per_set - self._labels_per_set
        output_shape = self._labels_per_set

        model_shape = self._architecture

        # Initialize a model
        self._model = NetworkFactory(
            model_shape=model_shape,
            activations=activations,
            input_shape=self._input_shape,
            output_shape=output_shape,
        )

        # Initialize a StockDataFactory
        self._data_factory = StockDataFactory(
            self._stock_name,
            self._points_per_set,
            self._num_sets,
            self._labels_per_set,
            self._testing_percentage,
            self._validation_percentage,
        )

        # Values being infered
        self._number_of_predictions: int | None = None
        self._end_date: str | None = None
        self._interval: str | None = None

        # Values that are being calculated
        self._raw_data: RAW_DATA | None = None
        self._sma: list[float] | None = None
        self._residuals: list[float] | None = None

        # Predictions
        self._predicted_residuals: list[float] | None = None
        self._predicted_closing_prices: list[float] | None = None
        self._extrapolated_sma: list[float] | None = None

        # Observed data
        self._observed_raw_data: RAW_DATA | None = (
            None
        )
        self._observed_sma: list[float] | None = None
        self._observed_residuals: list[float] | None = None
        self._observed_closing_prices: list[float] | None = None

    @property
    def predicted_closing_prices(self) -> list[float]:
        """
        Gets a deepcopy of the predicted closing prices.

        :return: predicted closing prices
        :rtype: list[float]
        """
        return deepcopy(self._predicted_closing_prices)

    def compare_predictions_with_observations(self) -> float:
        """
        Compare the model's predictions with the actual observed data.

        Note:
            Be cautious when performing this comparison. In some cases,
            there may not be enough data to compare predictions with actual
            values. This situation can arise if the selected end date and
            prediction window result in a period where:

                (current date) < (end date + prediction window)

            Ensure there is sufficient observed data covering the
            entire prediction period before attempting the comparison.

        :return: the mean squared error of the observed closing prices
        and the predicted closing prices
        :rtype: float
        """
        self._validate_predictions(self._predicted_closing_prices)
        self._validate_comparison_possibility()

        self._get_observations_data()

        data_len = len(self._observed_raw_data)

        mse = mean_squared_error(
            np.array(self._observed_closing_prices),
            np.array(self._predicted_closing_prices[: data_len]),
        )

        return mse

    def predict(
        self,
        number_of_predictions: int,
        raw_data_amount: int = 50,
        sma_lookback_period: int = 3,
        regression_window: int | None = None,
        end_date: str = "2024-09-01",
        interval: str = "1d",
    ) -> None:
        """
        Predicts the closing prices and residuals.

        :param number_of_predictions: the number of predictions
        :type number_of_predictions: int
        :param raw_data_amount: the amount of raw data to be generated,
        used for the plotting faculties of this factory as well, defaults to
        50
        :type raw_data_amount: int, optional
        :param sma_lookback_period: the lookback time used to calculate
        the simple moving average (this is a hyperparameter for the ML model)
        defaults to 3
        :type sma_lookback_period: int, optional
        :param regression_window: this is the window used by the
        linear regression extrapolation of the SMA. When left to None the
        window is set to be equal to the number_of_predictions,
        defaults to None
        :type regression_window: int | None, optional
        :param end_date: the end date of the raw data retrieval,
        defaults to "2024-09-01"
        :type end_date: str, optional
        :param interval: the scale of the candles, defaults to "1d"
        :type interval: str, optional
        """
        self._number_of_predictions = number_of_predictions

        self._train_model()

        self._get_raw_data(raw_data_amount, end_date, interval)

        self._predict_residuals(sma_lookback_period)

        self._extrapolate_sma(regression_window)

        self._predicted_closing_prices = self._calculate_closing_prices()

    def plot_predictions(self) -> None:
        """
        Plots the predictions and the raw data.

        :raise ValueError: if the predic method hasn't been used
        before trying to use this method
        """
        self._validate_predictions(self._predicted_closing_prices)

        # Initialize the plotting class
        plotter = PlotStocks(
            self._raw_data,
            self._sma,
            self._extrapolated_sma,
            self._residuals,
            self._predicted_closing_prices,
            self._predicted_residuals,
        )

        return plotter.masterPlot()

    def plot_comparison(self) -> None:
        """
        Plots the comparison between the predicted closing prices
        and the observed closing prices as well as the residuals.

        :raise ValueError: if the predic and
        compare_predictions_with_observations method haven't been used
        before trying to use this method.
        """
        self._validate_predictions(self._observed_closing_prices)

        # Initialize the plotting class
        plotter = PlotForcastComparison(
            self._observed_raw_data,
            self._observed_sma,
            self._extrapolated_sma,
            self._observed_residuals,
            self._predicted_closing_prices,
            self._predicted_residuals,
        )

        return plotter.masterPlot()

    def _train_model(self) -> None:
        """
        Helper method used to train the model.
        """
        # Get training data
        (
            training_data,
            validation_data,
            _,
            training_labels,
            validation_labels,
            _
        ) = (
            self._data_factory.get_stock_data()
        )

        # Train the model
        self._model.train(
            training_data,
            training_labels,
            validation_data,
            validation_labels,
            self._learning_rate,
            self._loss_function,
            self._metrics,
            self._epochs,
            self._batch_size,
        )

    def _get_raw_data(
            self,
            raw_data_amount: int,
            end_date: str,
            interval: str
    ) -> None:
        """
        Helper method to get raw data used for plotting
        utilising the DataFactory.

        :param raw_data_amount: the amount of raw data
        :type raw_data_amount: int
        :param end_date: the end date of the data retrieval
        :type end_date: str
        :param interval: the scale of the candlesticks
        :type interval: str
        """
        self._end_date = end_date
        self._interval = interval
        self._raw_data = self._data_factory.get_raw_data(
            raw_data_amount, end_date, interval
        )

    def _predict_residuals(self, sma_lookback_period: int) -> None:
        """
        Used to predict the residuals. First it calculates the SMA
        of the raw data, get's their residuals, preprocess them,
        and does the prediction.

        :param sma_lookback_period: the lookback period used to
        compute the SMA
        :type sma_lookback_period: int
        """
        # Calculate the SMA
        self._sma_lookback_period = sma_lookback_period
        self._sma = self._data_factory.get_sma(
            self._raw_data, self._sma_lookback_period
        )

        # Calculate the residuals
        self._residuals = self._data_factory.get_residuals_data(
            self._raw_data, self._sma
        )

        preprocessed_residuals = self._preprocess_residuals()

        # Predict the residuals
        self._predicted_residuals = self._model.predict(
            preprocessed_residuals, self._number_of_predictions
        )

    def _preprocess_residuals(self) -> tf.Tensor:
        """
        This method ensures that there are enough datapoints to fit
        the input shape of the model. After that it reduces the number
        of residuals to fit the input shape. Utilises tensorflow's
        convert_to_tensor method to create a tensor in the right shape
        for the prediciction method of the Model.

        :raises ValueError: if the number of datapoints is smaller
        than the input shape
        :return: resiudals in the form of a tensor object ready to
        be used as an input of a NN Model.
        :rtype: tf.Tensor
        """
        # Validate if there is enough data to be able to fit
        # the input shape of the model
        if len(self._residuals) < self._input_shape:
            raise ValueError(
                f"The number of residual {len(self._residuals)} is smaller\n"
                f"than the input shape {self._input_shape}.\n"
                "You can not perform a prediction!\n"
                "You can fix that by increasing 'raw_data_amount' in the "
                "'predict' method"
            )

        # Reduce the number of residuals
        reduced_residuals = self._residuals[-self._input_shape :]

        # Convert to tensors in the correct shape
        corr_shape = (-1, self._input_shape)
        residuals_tensor = tf.convert_to_tensor(reduced_residuals)
        residuals_tensor = tf.reshape(residuals_tensor, corr_shape)

        return residuals_tensor

    def _extrapolate_sma(self, regression_window: int | None) -> None:
        """
        Extrapolates the SMA using the DataFactory.

        :param regression_window: the regression window if specified.
        Adviced to be left to None.
        :type regression_window: int | None
        """
        self._extrapolated_sma = self._data_factory.get_extrapolated_sma(
            self._sma, self._number_of_predictions, regression_window
        )

    def _calculate_closing_prices(self) -> list[float]:
        """
        Calculates the closing prices from the extrapolated SMA
        and the predicted residuals.

        :return: a list of the predicted closing prices
        :rtype: list[float]
        """
        zipped = zip(self._extrapolated_sma, self._predicted_residuals)
        return [sum(x) for x in zipped]

    def _get_observations_data(self) -> None:
        """
        Calculates the obeserved raw data, the observed
        SMA, the observed residuals and the observed closing
        prices.
        """
        observed_raw_data = self._get_observed_raw_data()

        self._observed_sma = self._data_factory.get_sma(
            observed_raw_data, self._sma_lookback_period
        )

        self._observed_residuals = self._data_factory.get_residuals_data(
            observed_raw_data, self._observed_sma
        )

        start = self._sma_lookback_period
        self._observed_raw_data = observed_raw_data[start :]

        self._observed_closing_prices = self._data_factory.\
            get_closing_prices(
            self._observed_raw_data
        )

    def _get_observed_raw_data(self) -> RAW_DATA:
        """
        Gets the observed raw data.

        :return: the observed raw data
        :rtype: list[tuple[str, float, float, float, float]]
        """
        end_date = pd.bdate_range(  # Getting a range of bussiness days
            start=self._end_date, periods=self._number_of_predictions
        ).tolist()[
            -1
        ]  # Getting the last date

        end_date_str = str(end_date).split(" ")[0]  # Converting - yyyy/mm/dd

        observed_raw_data = self._data_factory.get_raw_data(
            number_of_points=(
                self._number_of_predictions + self._sma_lookback_period
            ),  # Taking the #-predictions + #-sma-lookback
            end_date=end_date_str,
            interval=self._interval,
        )

        return observed_raw_data

    def _validate_predictions(self, predictions: list[float]) -> None:
        """
        Validates if predictions have been made.

        :param predictions: the predictions
        :type predictions: list[float]
        :raises ValueError: if predictions haven't been made
        """
        if predictions is None:
            raise ValueError(
                "You need to make predictions first!"
                "Please first use the `predict` method."
            )

    def _validate_comparison_possibility(self) -> None:
        """
        Validates if it is possible to make a comparison
        between the predicted data and the observed data.

        :raises ValueError: raised if comparison is not possible
        """
        current_date = pd.Timestamp.now()
        end_date = pd.bdate_range(  # Getting a range of bussiness days
            start=self._end_date, periods=self._number_of_predictions
        ).tolist()[-1]

        if end_date > current_date:
            raise ValueError(
                "You can't perform a comparison as your"
                " predictions extend passed the current date!\n"
                "Your are predicting up until: "
                f"{str(end_date).split(' ')[0]}"
                "Try reducing the number of predictions, or change"
                " the end date to an earlier date!"
            )
